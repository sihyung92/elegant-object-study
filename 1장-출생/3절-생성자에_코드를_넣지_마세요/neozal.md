# 1.3 생성자에 코드를 넣지 마세요

- 인자에 손대지 말라
- 실제로 인자를 사용하는 순간까지 변환 작업을 연기하라
- 진정한 객체지향에서 인스턴스화란 더 작은 객체들을 조합해서 더 큰 객체를 생성한다.

```java
class Cash {
    private Number dollars;
    
    Cash(String dir) {
        this.dollars = new StringAsinteger(dlr);
    }
   
}

class StringAsInteger implements Number {
    private String source;

    StringAsInteger(String srg) {
        this.source = src;
    }
    
    int intValue() {
        return Integer.parseInt(this.source);
    }

} 
```

- 위와같은 소스를 작성해야 한다.
- 위와같은 소스가 성능상의 이득을 볼 수 있다
    - 이때 성능상의 이득이란 단순히 생각하는 '그것'이 아니고, 게으른 변환을 통해 얻는 성능이다.
    - 이 부분에서 많은 사람들이 의아해 할 것 같다. 간단한 예시를 들자면, 만일 어떤 객체 A의 생성자의 초기화 부분에서 DB에서 데이터를 가지고 와야 하는 경우가 있다고 가정해보자.
    그리고, 객체A가 엄청 많이 생성되고, 그 중에서 특정 필드가 true인것만 filter해서 어떤 작업을 수행한다 생각해 보자.
    만일 게으르지 않았다면 수많은 객체 A가 모두 dbconnection을 했을꺼고 성능상 손해가 심했을 것 이다.
    하지만 게을렀다면 filter된 객체들만 db connectino을 했을것이고, 이런경우 성능의 차이를 많이 느낄 수 있을것이라 생각한다.
    
    
# 내 생각

## 빠른 실패를 지향해야 한다.
과거에는 실패의 지연을 덕목으로 생각해 왔다. 하지만 요즘 와서는 빠른 실패를 하고 그에대한 리팩토링을 수행하는게 페러다임이 됐다.
이런편이 유지보수성이나 디버깅에서 모두 뛰어나다. 하지만 위와같은 방법은 실행을 지연시킨다. 이는 빠른 실패를 방해하며 디버깅의 어려움으로 귀결될 수 있는 문제를 야기한다.

## Optional을 사용할 수 있다.
예고르는 이 방식의 타당성을 부여하기 위해 데코레이터를 이용한 캐싱 기능을 소개한다.
하지만 생각해보면 이는 Optional과 완벽히 같은 기능을 수행하고 있는것을 알 수 있다.
굳이 데코레이터를 써야하나? 공식 API가 제공하는 Optinal로 대체하자.


개인적으로는 정말 마음에 들지 않는다. 지연된 실행이 주는 성능상의 이득도 있지만, 일반적인 경우(Integer.parseInt와 같은)는 그리 큰 성능 이득을 못느낄 것 이다.
객체지향적 사고를 하는건 좋지만 이건 조금 선 넘지 않았나 하는 생각이 든다.
객체지향적이 아니라 단순히 "구현"의 관점으로 보면, 위에서 내가 제시한 db connection 예시와 같은 경우는 사용하지 좋을 것 같다.