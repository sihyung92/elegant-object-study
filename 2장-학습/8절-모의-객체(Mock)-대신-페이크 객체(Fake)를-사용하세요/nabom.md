우리는 더 빠른 테스트를 위해 모의 객체(Mock)를 만들어 사용한다. 하지만 모킹은 'bad practice'이고 최후의 수단으로만 사용해야 한다. 모킹은 테스트가 매우 장황해지고 이해하거나 리팩토링하기 어려워진다. 하지만 페이크 객체(Fake)를 사용하게 되면 테스트가 더 짧아지고 유지보수성이 눈에 띄게 향상된다. 페이크 객체를 생성하는 방법은 다음과 같다.

```java
interface Exchange {
	float rate(String origin, String target);
	final class Fake implements Exchange {
		@Override
		float rate(String origin, String target) {
			return 1.234;
		}
	}
}
```

페이크 객체 접근 방식은 다음과 같다. `Exchange exchange = new Exchange.Fake();`

단위 테스트만을 위해 또 다른 과정을 추가할 수도 있고 매우 유연해지는 코드이다. 최대한 인터페이스를 제공한다면 페이크 객체도 같이 제공해 아름다운 테스트 코드를 만들자!

### 느낀점

인터페이스를 사랑하는 것과 테스트와 프로덕션은 하나다 라는 신념을 가지고 있는 예고르 형님의 철학을 잘 볼 수 있었던 장이었던 것 같다.

하지만, 목 객체와 페이크 객체는 좀 다르게 봐야되는 것 같다. 페이크 객체는 만들어 두면 고정 값만 리턴해주고 목 객체는 테스트에서 필요한 때에 원하는 값을 리턴해주는 차이가 있는 것 같다. 예를 들어 페이크 객체는 1.234 만 리턴하는데 테스트 코드에서는 100 이상의 값을 테스트하고 싶을 때이다.

또한, 정말 테스트 코드와 프로덕션 코드는 하나일까? 현실적으로는 불가능한 것 같다. 테스트 빌드 방식과 프로덕션 코드 빌드 방식, 테스트와 프로덕션의 서로 다른 라이브러리 의존성(MockMvc), 서로 다른 테스트 환경(H2 in memory) 등등, 이미 많은 곳에서 둘의 개념을 분리한다. 그렇다면 테스트 의존적인 페이크 객체를 프로덕션 코드에 둬도 괜찮을 걸까? 프로덕션 코드만큼 테스트 코드의 중요성이 크다는 것은 동의하지만 둘은 엄연히 분리해야하는 개념같다. 즉, 프로덕션 코드에 테스트를 위한 코드는 지양하는 것이 좋은 것 같다.