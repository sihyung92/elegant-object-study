# **2.3 -항상 인터페이스를 사용하세요**

## **정리**

### **객체들의 세계는 매우 사회적이면서 유대감이 높아요.**

객체들은 서로를 필요로 하기 때문에 **결합돼요.**

결합은 어떤 객체가 어떤 일을 수행행 해야하고, 다른 객체에게 어떤 서비스를 제공하는 지를 정확하게 알고 있게 해줘요. 그렇기에 유용해 보여요. 

하지만 애플리케이션이 성장하고 객체들의 수가 많아질수록 **강한 결합도**가 심각한 문제로 떠올라요.

### **높은 의존성과 낮은 결합도를 항상 생각해야 해요.**

결합도 문제는 유지보수성에 영향을 미쳐요. 유지보수성이 가장 중요해요.

### **유지보수성을 높이기 위해선 최선을 다해서 객체를 분리해야해요.**

기술적인 관점에서 객체 분리란 `상호작용하는 다른 객체를 수정하지 않고도 해당 객체를 수정할 수 있도록 만든다는 것`이에요. (변경에는 닫혀 있어야 하고, 확장에는 열려 있어야함)

이를 가능하게 해주는 가장 훌륭한 도구가 **인터페이스**예요.

```java
interface Car {
    Car go();

    Car back();

    int getDistance();
}
```

Car는 인터페이스에요. 다시 말해서 우리의 객체가 다른 객체와 의사소통하기 위해 따라야하는 **계약**이에요.

```java
class DefaultCar implements Car {
    private final int distance;

    DefaultCar(int distance) {
        this.distance = distance;
    }

    @Override
    public Car go() {
        return new DefaultCar(distance + 1);
    }

    @Override
    public Car back() {
        return new DefaultCar(distance - 1);
    }

    @Override
    public int getDistance() {
        return double;
    }
}
```

자동차가 필요하다면, 실제 구현 대신 **계약**에 의존하면 돼요.

```java
class People {
    private Car car;
}
```

People 클래스는 Car 인터페이스의 구현 방법에 아무런 관심이 없어요. 메서드가 어떻게 동작하는지도 관심이 없어요. 즉 `동작 방식을 알지 못해`요.

### **모든 퍼블릭 메서드가 인터페이스를 구현하도록 만들어야해요.**

올바르게 설계된 클래스라면 최소한 하나의 인터페이스라도 구현하지 않는 퍼블릭 메서드를 포함해서는 안돼요.

즉 다음과 같이 설계해서는 안돼요 

```java
class Car {
    public int move(){
        //작업 수행
    }
}
```

move()는 어떤 것도 오버라이드 하지 않기 때문에 문제가 있어요. 이 설계는 클래스의 사용자(다른 클래스)로 하여금 이 클래스에 강하게 결합되도록 조장해요. 

직접적으로 Car.move()를 사용할 수 밖에 없기 때문에 새로운 메서드를 이용해서 구현을 대체할 수 없어요. 

### 클래스가 존재하는 이유는 다른 누군가 클래스의 서비스를 필요로 하기 때문이에요

서비스는 계약이자 인터페이스이기 때문에 클래스가 제공하는 서비스는 어딘가에 문서화 되어있어야해요.  

서비스 제공자들은 서로 경쟁헤요. 이는 동일한 인터페이스를 구현하는 여러 클래스들이 존재한다는 말이에요. 그리고 각각의 경쟁자는 서로 다른 경쟁자를 쉽게 대체할 수 잇어야해요. 이것이 **느슨한 결합도**의 의미에요

즉, 요소들 사이의 계약으로서 인터페이스는 우리가 전체적인 환경을 구조화된 상태로 유지할 수 있도록 해줘요.

## **의견**

짧은 문장에 많은 뜻이 있어 정리하기 어려웠어요. 모든 클래스는 인터페이스를 구현 해야한다는 말이 지금은 어려워요. 이또한 의식적으로 연습해야 할 부분이라 생각해요.