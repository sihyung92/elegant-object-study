# 2.6 불변 객체로 만드세요.

# Contents

불변 객체는 필요한 모든 것을 내부에 캡슐화하고 변경할 수 없도록 통제합니다. 불변 객체를 수정해야 한다면 프로퍼티를 수정하는 대신 새로운 객체를 생성해야 합니다. 

```
class Cash {
    private int dollars;
    public void mul(int factor) {
        this.dollars *= factor;
    }
}

class Cash {
    private final int dollars;
    public Cash mul(int factor) {
        return new Cash(this.dollars * factor);
    }
}
```

불변 객체는 자기 자신을 수정할 수 없고, 항상 원하는 상태를 가지는 새로운 객체를 생성해서 반환해야 한다.

## 불변객체를 사용해야 하는 이유
1. 식별자 가변성 - 가변 객체의 경우 다른 자료 구조를 사용할 때, 자료구조에 해당 가변 객체의 값을 넣어 둔 뒤 값을 변경할 경우 해당 자료구조 내에서 식별자가 변경되게되는 이슈가 생긴다. (ex. map)
2. 실패 원자성 - 완전하고 견고한 상태거나, 실패하거나 둘 중 하나의 상태를 갖는다. 따라서 불변 객체로 만든다면 실패 시에는 내부의 어떤 것도 수정할 수 없도록 하고, 성공 시 아예 새로운 객체를 반환하도록 할 수 있다. 만약 가변 객체라면 중간에 **일부만** 변경될 수 있는 위험이 존재한다.
3. 시간적 결합 - 어떤 객체를 선언할 때, setter를 이용해서 프로퍼티를 초기화한다면 초기화 순서에 따라 값의 상태가 달라질 수 있다. 하지만 불변 객체를 이용한다면 프로퍼티의 초기화는 생성자에서만 가능하므로 시간적 결합에 대한 이슈를 없앨 수 있다.
4. 부수효과 제거 - 객체가 가변인 경우 누구든 손쉽게 객체를 수정할 수 있다. (이 말 만으로도 4번은 증명되는 것 같다)
5. NULL 참조 없애기 - 3번과 관련있다. setter가 아닌 생성자에서 초기화함으로 NULL 이 생기는 것은 생성자에 null을 전달한 경우밖에 없다.
6. 스레드 안전성 - 불변이므로 당연하지 않을까?
7. 더 작고 더 단순한 객체 - 250줄을 넘는 클래스는 리팩토링이 필요하다. 불변 객체의 경우에는 프로퍼티를 생성자를 이용해 초기화해야하므로 가변 객체에 비해 더 작고, 더 단순한 객체가 될 수 밖에 없다.

## 의견
불변 객체의 장점은 매우 많다고 생각한다. 그리고 가변 객체에 비해 불변 객체를 이용하는 것이 더 좋은 방법인 것에도 동의한다. 그리고 책을 읽다 보니 #9 에서 불변 객체에서의 조정자는 객체를 리턴해야하는가? 에 대한 답으로 O를 할 수 있는 듯 ? 

아무튼, 읽다보니 저자의 불변 객체 옹호는 이해가 되는데 그렇다면 가변 객체는 왜 필요할까? 
이에 대해 stackoverflow의 [why we need mutable classes?](https://stackoverflow.com/questions/23616211/why-we-need-mutable-classes)에서 채택받은 답변을 내가 이해한 바로는 "A-Z까지의 객체를 생성할 때 중간 과정에서 많은 객체가 (낭비적) 생성이 될 수 있고, 또한 어차피 Z로 갈거라면 생성에 소비할 필요가 없다. 예를 들어 문자열 배열과 같은 경우, 어차피 1000개의 문자열을 연결하여 하나의 결과를 생성해야 할 때, 불변 객체를 이용한다면 중간에 낭비될 98개의 중간 개체를 생성해야한다. 또한 정렬이나 필터링과 같은 상황에서는 정렬이나 필터링되길 원하는 객체의 사이즈가 작다면 문제되지 않지만, 매우 크다면 정렬 후 새로운 컬렉션을 반환할 때 낭비가 될 수 있다." 는 이유로 가변 객체가 필요하다고 이해하였다. 이와 더불어 자료구조 같은 것들을 가변 객체를 이용해 더 쉽게 구현할 수 있을 것이라 생각함!

아무튼 불변 객체의 장점이 더 많지만, 가끔은 가변객체가 더 적절할 때가 있는 것 같다. 상황에 알맞게 사용하면 될 듯!?

