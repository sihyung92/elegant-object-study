# 2.6 불변 객체로 만드세요
불변 클래스로 구현하면 크기가 작고, 응집력이 높으며, 유지보수하기 쉬운 클래스를 만들 수 있습니다.<br>

<br>

### 장점1. 식별자 가변성
객체의 상태가 변경되었을 경우 두 객체는 동일한가?<br>
예를 들어 객체 A와 객체 B가 Map에 담겨있다고 했을 때, 객체의 상태가 변경되어 객체 B와 상태가 같아진다면 어떻게 될까?<br>
이러한 에러를 방지할 수 있는 것이 불변 객체이다.<br>

<br>

### 장점2. 실패 원자성
완전하고 견고한 상태의 객체를 가지거나 아니면 실패하거나 둘 중 하나만 가능하다는 특성을 의미한다.<br>
가변 객체의 경우 상태가 변경될 때 그 안에서 별도의 처리를 함으로써 실패 원자성을 보장할 수는 있다.<br>
하지만 객체의 복잡성이 훨씬 더 높아지고, 실수할 가능성이 커지기 때문에 불변 객체로 사용하는 것이 이 특성을 지키기에 편리하다.<br>

<br>

### 장점3. 시간적 결합
불변 객체를 이용하면 시간적 결합을 제거할 수 있다.<br>

```java
Cash price = new Cach();
// x를 계산하기 위한 로직들
price.setDollars(x);
// y를 계산하기 위한 로직들
price.setCents(y);
// 다른 일을 수행하기 위한 로직들
System.out.println(price);
```

위와 같이 시간적 결합이 생기게 되면 코드의 복잡도가 증가함에 따라 유지보수가 어려워진다.<br>

<br>

private 프로퍼티가 NULL값을 가지도록 골격을 만들고, setter를 통해 프로퍼티 값을 설정하여 초기화하는 것은 JPA, JavaBeans와 같은 다양한 표준에서 Java 객체 조작을 위해 권장되는 방식이다.<br>
하지만 객체 사고의 관점에서는 잘못되었다고 말한다.<br>

<br>

나는 예고르씨가 생성자에 로직을 넣지말라고 말할 때 들었던 예시가 위와 같은 흐름이라고 생각한다.<br>
내가 이해를 잘못한 것이 아니라면 이 사람은 자기 논리에 발목이 잡힌 게 아닐가...<br>

<br>

### 장점4. 부수효과 제거(side effect-free)
객체는 예측가능해야한다. 그래야 믿고 사용할 수 있다.<br>

<br>

### 장점5. NULL 참조 없애기
구구절절 설명했지만 결국 객체가 불변한다면 애초에 NULL이라는 값 자체가 들어올 수가 없다는 말.<br>

<br>

### 장점6. 스레드 안정성
객체가 여러 스레드에서 동시에 사용될 수 있으며 그 결과를 항상 예측할 수 있었야한다.<br>
synchronized 처리를 통해 스레드에 안전하게 만들 수는 있지만 쉽지 않고,  (뭐가 쉽지 않다는 건디)<br>
동기화 로직을 추가하는 일은 성능상의 비용을 초래한다. (각 스레드가 객체를 사용하기 위해 객체가 다른 스레드로부터 해방 될때까지 기다려야한다.)<br>

<br>

### 장점7. 단순성
단순성 = 유지보수성<br>
객체가 단순해질 수록 응집도는 더 높아지고 유지보수는 더 쉬워진다.<br>
단순하다는 것은 더 적은 코드 줄 수를 의미한다. <br>
<br>
클래스가 짧을 수록 하는 일이 무엇이고, 어디에서 실패하고, 어떻게 리팩토링해야하는 지를 더 쉽게 이해할 수 있다.<br>

<br>

예고르씨가 불변객체를 사용하는 가장 큰 이유인 단순성에 대한 이야기를 듣고 있자니 그래서 그렇게 나노 단위로 클래스를 나눴구나 싶다.<br>