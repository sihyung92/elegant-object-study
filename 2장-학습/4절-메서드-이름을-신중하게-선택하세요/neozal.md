# 2.4 메서드 이름을 신중하게 선택하세요

- 빌더 : 무언가를 만들어 내는 것 (반환값이 있는 것) 
    - 명사로 만들어라
- 조정자 : 상태를 변화시키는 것 (반환값이 없는 것)
    - 동사로 만들어라
- 빌더와 조정자 혼합
    - 두가지 일을 따로 하는 객체를 만들어 반환하라
- boolean 값을 결과로 반환하는 경우
    - 형용사로 지어야 한다.
    - 중복이 되는 is는 뺀다 (empty(), readable() ...)
 
# 내 생각
아주 좋다고 생각한다. 객체를 객체로서 존중하며, 절차지향과 객체지향의 차이점을 극명히 드러내는 장이라고 생각한다.

## 빌터는 명사로
객체는 살아있는 유기체다. 따라서 객체에서 "무엇을 하라" 고 "세세하게" 명령하는것은 그 존재를 무시하는 행동을 하는 것 이다.
단지 그에게 "내가 이런게 필요한데 좀 줄 수 있니?" 라고 물어보며 그를 존중해 줘야한다.

사실 이런 설명이 너무 추상적이고 객체지향에 미친놈의 생각이라고 생각할 수도 있다. 그렇다면 캡슐화의 관점에서 설명해 보겠다.

우리가 객체를 만드는 이유는 무엇일까? 왜 캡슐화를 통해 행동을 감추는 걸까?
내 생각으로 가장 큰 이유는 클라이언트의 관심사를 객체로부터 분리하고, 기능의 유지보수에 용이하게 하기 위해서이다.

클라이언트의 관심사를 객체로부터 분리한다는건 무슨 의미일까? 바로 객체의 내부 구현에는 신경쓰지 않겠다는 의미이다.
클라이언트는 사용하는 객체의 내부 구현을 신경쓰지 않고 단지 public 인터페이스를 통해서만 메세지를 주고받기 때문에 객체의 내부에 변화가 일어나는지 전혀 알지 못한다.
즉, OCP가 만족된다. 이 이야기를 왜 했을까?

빌더를 명사로 만들지 않을 경우를 보자.
책에서 소개한 예시를 기반으로 한번 소개해 보겠다.
```java
InputStream load(URL url);
String read(File file);
int add(int x, int y);
```
위 메소드들의 공통점은 무엇인가? 모두 "객체의 행동"을 정의하고 있다.
객체에게 "로드하라", "읽어라", "더해라" 라고 명령한다. 이는 객체의 내부 구현을 클라이언트가 신경쓰게 된다는 것과 마찬가지다.

캡슐화에서 클라이언트는 사용하는 객체의 내부 구현을 몰라야한다. 그냥 그 객체가 뭔가해서 줄거라고 믿어야 한다.
철학적 접근이든 기술적 접근이든 저런 네이밍은 문제를 야기한다. 
만일 위 load 메서드를 호출했는데 url을 load하지 않고 캐싱된걸 그냥 던져줬으면? 클라이언트는 이를 제대로 구현이 안된 메소드르 생각할 수도 있다.
(사실 이런 관점은 크게 중요하지 않다. 객체지향적으로 생각하는게 더 중요하다.)

## 조정자는 동사로
조정자의 경우도 마찬가지다. 아마 위에서는 객체한테 뭐 시키지 말라더니 이번엔 왜 동사로 하냐고 태클이 들어올 수 있다.
하지만 빌더는 데이터를 받아오는 것에 관점이 있고, 조정자는 내부 상태를 수정하는 것에 관점이 있다는 것을 인지해야 한다.
조정자의 메서드 명을 동사로 하더라도 그 행위를 어떻게 하는지는 객체에 숨겨져 있다. 따라서 동사의 이름도 문제가 없다.

## 빌더와 조정자 혼합하기
사실, 이부분은 큰 공감을 못하겠다. 너무 원칙을 중시하다가 나아가 버린 느낌...? 그냥 메서드 이름에 하는 행동과 반환값까지 명시하면 되지 않을까?
```java
class Document {
    int write(InputStream content);
}
->
class Document {
    int writeAndReturnSavedBytes(InputStream content);
}
```
이런식으로...

## boolean값을 결과로 반환하는 경우
예고르의 실수일까...? 이 절에서 예고르는 "읽을 수 있는 코드"를 중시하고 그걸 위해서 형용사를 추천한다.
하지만 그런 이유라면 굳이 형용사가 아니더라도 충반히 가능하다.
심지어
```java
    A.isExisting();
    A.isExistable();
```
나는 전자의 경우가 더 자연스럽다고 생각한다...
그냥 개발자들의 관례에 맞게 쓰는편이 더 좋다고 생각한다.

 