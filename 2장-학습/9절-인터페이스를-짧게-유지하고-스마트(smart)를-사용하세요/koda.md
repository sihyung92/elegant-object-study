# 2.9 인터페이스를 짧게 유지하고 스마트(smart)를 사용하세요 

## 내용

인터페이스는 다중 상속을 할 수 있기 때문에 인터페이스를 작게 유지하는 것이 클래스를 작게 유지하는 비결이다. 인터페이스에 너무 많은 메서드가 정의되어 있다면 SRP를 위반한 것과 마찬가지이다.

이때 인터페이스를 구현하는 구현체의 공통된 작업들을 구현하기 위해 Smart 클래스를 활용하자.

```java
interface Exchange {
	float rate(String source, String target);
	
	final class Smart {
		private final Exchange origin;
		public float toUsd(String source) {
			return this.origin.rate(source, "USD");
		}
	
		public float eurToUsd() {
			return this.toUsd("EUR");
		}
	}
}

//사용시
float rate = new Exchange.Smart(new NYSE())
									.eurToUsd();
```

스마트 클래스의 크기는 더 커질 수 있지만 인터페이스의 크기 자체는 작게 유지된다. 또한 공통 기능이 인터페이스와 함께 베포되어 코드 중복을 피할 수 있다.

## 의견 및 의문

- 이 챕터에서 말한 Smart 객체 또한 이전 챕터의 Fake 객체와 마찬가지로 처음 접하게 된 개념이라서 굉장히 흥미롭게 읽었다.
- Smart 객체로 공통 부분을 추출하고 인터페이스를 작게 유지하는 것에 대한 아이디어에는 동의한다. 하지만 이렇게 inner 클래스를 활용하는 것이 익숙하지 않아서 그런지 이렇게 구현하는 것이 얼마나 편리할지에 대해서는 더 경험하고 말할 수 있을 것 같다.
- Smart 클래스의 존재 여부, 그리고 어떠한 메소드가 Smart 클래스에 있을지 신경쓰고 소통하는 것에 대한 비용이 발생할 것 같다.
- 더불어 Smart 클래스를 인터페이스의 메소드에 포함하지 않기 때문에 예고르가 말한 것처럼 '점점 더 커지는' 것에 대한 우려도 있을 것 같다. 모든 공통 메소드를 다 집어 넣어 배보다 배꼽이 큰 상황이 될 수도 있을 것 같다.
- 개인적으로 이전에 미션을 진행할 때 `인터페이스 → 추상클래스에서 일부 공통 메소드 구현 → 해당 추상클래스를 구현하는 구현체 생성` 하는 방법으로 인터페이스의 공통 기능들의 중복을 줄인 것이 매우 편리하다고 느겼는데 Smart 클래스를 통해서 하는 것과 어떠한 차이가 있을까? 위의 설계가 Smart 클래스를 대체할 수 있는 걸까?