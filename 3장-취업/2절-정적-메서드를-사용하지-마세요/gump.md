# 3.2-정적 메서드를 사용하지 마세요

## 정리

### OOP에 static을 도입한 사람이 누구인지는 알 수 없지만 이들은 순수한 악이에요. 정적 메서드 그 자체가 악이란 말이에요.

**변경 전**

```java
class WebPage {
    public static String read(String url) {
        // HTTP 요쳥을 만들고
        // UTF-8 문자열로 변환한다
    }
}
```

이제 아주 간단한 방식으로 WebPage 클래스를 사용할 수 있어요

```java
String html = WebPage.read("http://www.java.com");
```

이 방식은 필자가 아주 강하게 반대하는 메서드의 일종이에요. 

더 나은 방식은 정적 메서드 대신 객체를 사용하는 것이에요

**변경 후**

```java
class WebPage {
    private final String url;

    WebPage(String url) {
        this.url = url;
    }

    public String content() {
        // HTTP 요쳥을 만들고
        // UTF-8 문자열로 변환한다
    }
}
```

다음은 이 클래스를 사용하는 방법이에요

```java
String html = new WebPage("http://www.java.com")
                .content();
```

### 정적메서드가 더 좋아보일 수 있어요

정적 메서드는 객체를 만드는 것 보다 더 빠른데, 웹 페이지의 내용을 읽고 싶을 때마다 새로운 객체를 생성할 필요가 없기 때문이에요.

간단하게 정적 메서드를 호출하고, 작업을 수행하고, 결과를 얻은 후, 다음 단계로 진행해요.

객체 생성과 가비지 컬렉션에 신경 쓸 필요가 없어요. 뿐만 아니라 WebUtils와 같은 '유틸리티'클래스에 정적 메서드를 모아둘 수 있어요. WebUtils에 포함된 메서드들은 웹 페이지를 읽고, 업데이트하고, 통계 정보를 얻고, 응답 시간을 계산하는 작업들을 지원해요. 많은 메서드를 모아 놓고 쉽고 간편하게 사용할 수 있어요.

사용성 측면에서도 매우 직관적이에요. 모든 사람들이 정적 메서드가 어떻게 동작하는지 이해하고 있어요.

WebPage.read()라는 문장을 읽는 순간 페이지가 로드될 것 이라는 사실을 쉽게 알아챌 수 있어요. 우리는 컴퓨터에게 명령을 지시하고, 컴퓨터는 명령을 실행해요. 간단하고 명확하지 않나요?

`안타깝게도 이런 방식은 완전히 잘못됐어요`

### 문맥에 상관없이 정적 메서드를 사용하고 있는지 여부는 OOP를 제대로 이해하지 못한 형편없는 프로그래머를 구별하기 위해 사용할 수 있는 최적의 지표에요

다시 한번 강조해요, 정적 메서드의 사용을 중단해야해요. 정적 메서드의 단점은 한 마디로 요약할 수 있어요. 정적 메서드는 소프트웨어를 유지보수하기 어렵게 만들어요. 

결국 모든 것이 유지보수성과 관련이 있기에 놀라운일이 아니에요.

### 1. 객체 대 컴퓨터 사고(Object vs. computer thinking)

'**컴퓨터적으로 생각하기'라는 제목이 여기서 다룰 문제에 더 적합해요**

```java
int max(int a, int b) {
    if (a > b) {
        return a;
    }
    return b;
}
```

이 코드는 문제가 있어요.

우리는 컴퓨터에게 두 정수의 최댓값을 구하는 방법을 알려줘요. 우리가 결정하고, 컴퓨터는 따라요. 이 흐름은 항상 순차적이며 스크립트의 위에서 아래로 흘러요.

이러한 순차적인 사고 방식을 가리켜 '컴퓨터 입장에서 생각하기'라고 불러요.

```java
class Max implements Number {
    private final Number a;
    private final Number b;

    public Max(Number left, Number right) {
        this.a = left;
        this.b = right;
    }
}
```

```java
Number x = new Max(5, 9);
```

위 코드는 최댓값을 계산하지 않아요. 그저 x가  5와 9의 최댓값이라는(is a) 사실을 정의할 뿐이에요

Max클래스의 객체 안에 포함된 것이 무엇이고, 이 클래스가 Number 인터페이스를 정확히 어떻게 구현하고 있는 지에는 관심이 없어요. CPU에게 계산과 관련된 어떤 지시도 내리지 않고, 단순히 객체를 생성할 뿐이에요.

이런 측면에서 OOP는 함수형 프로그래밍과 매우 유사해요.

반대로, OOP의 정적 메서드는 OOP와 아무런 상관이 없으며, 객체지향 언어의 문법을 이용해서 절차적인 코드를 작성하도록 부추길 뿐이에요. 

다음은 정적 메서드를 이용해서 최댓값을 구하는 Java 코드예요.

```java
int x = Math.max(5, 9);
```

형편 없을 정도로 잘못된 방식이며, 올바른 객체지향 설계에서는 정적 메서드를 사용해서는 안돼요.

### 2. 선언형 스타일 대 명령형 스타일(declarative vs. imperative style)

**명령형** 프로그래밍에서는 '프로그램의 상태를 변경하는 문장(statement)을 사용해서 계산 방식을 서술'해요

이와 달리 **선언형** 프로그래밍에서는 '제어의 흐름을 서술하지 않고 계산 로직을 표현'해요

### 명령형 프로그래밍은 컴퓨터처럼 연산을 차례대로 실행해요

### 선언형 프로그래밍은 '엔티티'와 엔티티 사이의 '관계'로 구성되는 자연스로운 사고 패러다임에 더 가까워요

정적 메서드를 사용하든, 객체를 사용하든, 여전히 어딘가에서는 if(a>b)가 참인지를 확인해야해요. 

하지만 이 둘의 차이점은 다른 클래스, 객체, 메서드가 이 기능을 사용하는 방법에 있어요.

```java
public static int between(int l, int r, int x) {
    return Math.min(Math.max(l, x), r);
}
```

두 개의 정수로 구성된 간격이 있고, 그 간격 사이에 존재해야 하는 또다른 정수가 있다는 가정에서, 이 정수가 간격 안에 포함되는지 여부를 확인하고 싶을때, max()가 정적 메서드라면 위와 같이 구현해야해요.

between 메서드를 호출하자마자 9라는 값을 반환 받아요. 메서들르 호출한 시점에 CPU가 즉시 결과를 계산해요. 이것이 바로 명령형 스타일이에요. 

그렇다면 선언형 스타일은 어떨까요 

```java
class Between implements Number {
    private final Number number;

    public Between(Number left, Number right, Number x) {
        this.number = new Min(new Max(left, x), right);
    }
    
    @Override
    public int intValue() {
        return this.num.intValue();
    } 
}
```

이 클래스를 사용하는 예제는 아래와 같아요

```java
Between y = new Between(5, 9, 13);
```

아직까지는 CPU에게 숫자를 계산하라고 말하지 않았기 때문에. 이 방식은 선언형 스타일이에요.

Between이 무엇인지만 정의하고, 변수 y의 사용자가 intValue()의 값을 계산하는 시점을 결정해요. 계산이 아예 실행되지 않을수도 있기 때문에 Cpu는 결과가 9라는 사실을 아예 모를 수 있어요.

어떤 일을 하라고 지시하지 않고, 오직 선언만 했다는 점이 중요해요 

### 선언형 형식은 빨라요

정적메서드 하나를 불러오는 것 보다 인스턴스를 생성하는 것이 시간이 더 걸리긴해요. 하지만 다수의 정적 메서드를 호출해야 하는 경우에는 이야기가 달라요.

필요한 메서드만 선택적으로 호출할 수 있는 객체방식과 달리 정적 메서드 방식에는 작업을 완료하는데 필요한 모든 정적 메서드를 순차적으로 호출해야해요.

### 선언형히 좋은 첫 번째 이유. 실행 관점에서 선연형 방식이 더 최적화 되었기 때문에 빨라요

직접 통제할 수 있는 코드가 많을수록 유지보수하기도 더 쉬워져요. 

컴파일러, 가상머신, CPU가 실행 흐름을 최적화하는 대신, 소스코드 수준에서 우리가 직접 최적화할 수 있기 때문이에요

### 두 번째 이유. 다형성의 축복을 누릴 수 있어요

위의 예제에서, Between, Max, Min은 모두 클래스이기 때문에 쉽게 분리할 수 있어요. 객체지향 프로그래밍에서 객체는 일급 시민이지만, 정적 메서드는 그렇지 않아요.

객체를 다른 객체로부터 완전히 분리하기 위해서는 메서드나 주 ctor 어디에서도 new연산자를 사용해서는 안돼요.

명령형 코드에서는 객체와 달리 분리할 수 없어요.

### 세 번째 이유. 선언문의 표현력이 높아요

선언형 방식은 결과를 이야기하는데 반해, 명령형 방식은 수행 가능한 한 가지 방법을 이야기해요. 

명령형 방식에서 결과를 예상하기 위해서는 먼저 머릿속에서 코드를 '실행'해야하기 때문에 명령형 방식이 선언형 방식보다 덜 직관적이에요.

```java
Collection<Integer> evens = new LinkedList<>();
for (int number : numbers) {
    if (number % 2 == 0) {
        evens.add(number);
    }            
}
```

이 코드가 하는 일을 이해하기 위해서는 코드의 실행경로를 추적해야 해요. 

코드 안의 루프를 '마음 속으로 시각화'해야 해요. CPU가 코드를 읽는 방식을 코드를 읽는 사람도 동일하게 수행해야 해요.

동일한 알고리즘을 선언형 스타일로 작성한 예에요.

```java
Collection<Integer> evens = new Filtered(
        numbers,
        new Predicate<Integer>() {
            @Override
            public boolean suitable(Integer number) {
                return number % 2 == 0;
            }
         }
);
```

이 코드는 앞의 코드보다는 훨신 영어에 가까워요.

글자 그대로 "evens는 짝수만 포함하는 필터링된 컬렉션입니다"라고 읽혀요, 구현 방식을 몰라도 돼요.

이 코드에서 알아야 하는 것은 컬렉션이 '필터링' 되었다는 사실뿐이에요. 코드에는 구현과 관련된 세부 사항은 감춰져 있고, 오직 행동만 표현되어 있어요

### 알고리즘과 실행 대신 객체와 행동의 관점에서 사고하기 시작하면 무엇이 올바른지 느낄거에요.

명령형 스타일이 알고리즘과 실행을 다루는 방법이라면, 선언형 스타일을 정확하게 객체와 행동에 관한 방법이에요.

### 네 번째 이유. 응집도

두 번째 코드에서는 '계산'을 책임지는 모든 코드들이 한 곳에 뭉쳐 있기 때문에 실수라도 분리할 수 없어요.

하지만 첫 번째 코드에서는 코드의 각 줄을 이어주는 '접착제'가 없어요. 실수로 코드의 순서를 쉽게

 변경할 수 있으며, 알고리즘 오류를 낳아요.

### 절대로 명령형 스타일을 쓰지말아요.

라이브러리가 매우 유명하고 유용하기 때문에 제거할 엄두가 나지않는다면, 우리의 코드가 객체를 직접 처리할 수 있도록 정적 메서드를 감싸는 클래스를 만들어 종양을 고립시키는 것이에요.

Apache Commons에는 텍스트를 줄 단위로 읽는 정적 메서드는 FileUtils.readLine()이 포함되어 있어요. 이 정적 메서드를 아래와 같이 변경할 수 있어요.

```java
class FileLines implements Iterable<STring> {
    private final File file;
    public Iterator<String> iterator () {
        return Arrays.asList(FileUtils.readLines(this.file)).iterator();
    }
}
```

이제 아래와 같은 방법으로 텍스트 파일에 저장된 모든 내용을 읽어 올 수 있어요.

```java
Iterable<Stringq> lines = new FileLines(file);
```

결론은 모든 정적 메소드를 없앨 수 있어요.

### 3. 유틸리티 클래스

### 실제로는 클래스가 아니라 편의를 위해 다른 메서드들이 사용하는 정적 메서드들을 모아 놓은 정적 메서드들의 컬렉션(다른 말론느 헬퍼')라고 불러요.

가장 널리 알려진 유틸리티 클래스로는 java.lang.Math가 있어요.

### 유틸리티 클래스를 클래스라고 부르기 어려운 이유는 인스턴스를 생성하지 않기 때문이에요

섹션 1.1에서 객체와 클래스의 차이점을 설명하며, 클래스를 '객체의 팩토리'라고 정의했어요. 이 정의에 따르면 유틸리티 클래스느 어떤 것의 팩토리가 아니기 때문에 진짜 클래스라고 부를 수 없어요. 

유틸리티 클래스를 구현할 때는 '클래스'의 인스턴스가 생성되는 것을 방지하기 위해 private ctor를 추가하는 것이 좋아요. 이렇게 추가하면 클래스에 선언된 메서드를 제외한 어느 누구도 클래스의 인스턴스를 생성할 수 없어요.

### 하지만 유틸리티 클래스는 끔찍한 안티 패턴이에요. 가까이 하지 마세요.

유틸리티 클래스는 절차적인 프로그래머들이 OOP라는 영토에서 거든 승리의 상징이에요. 유틸리티 클래스는 정적 메서드처럼 단순히 나쁜 요소가 아니에요. 나쁜 요소들을 모아 놓은 집합체에요.

### 4. 싱글톤(singleton) 패턴

### 싱글톤 패턴은 정적 메서드 대신 사용할 수 있는 매유 유명한 개념이에요.

싱글톤 안에는 하나의 정적 메서드가 존재하며, 싱글톤의 형태는 일반적인 객체와 거의 유사해 보여요. 하지만 자세히 보면 일반적인 객체와는 매우 다르다는 사실을 알 수 있어요.

### 싱글톤은 유명한 디자인 패틴이지만, 사실 끔찍한 안티 패턴이에요

유틸리티 클래스와 별반 다를게 없는데, 싱글톤 패턴이 발명된 이유는 무엇일까요? 

### 안좋은 대답은 싱글톤은 상태를 캡슐화 했다는 말이에요

유틸리티 클래스에서도 충분히 상태를 가질 수 잇어요.

### 논리적으로 납득할만한 유일한 답은 싱글톤은 분리 가능한 의존성으로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다는 것이에요

즉 싱글톤의 장점은 getInstance()와 함께 setInstance()를 추가할 수 있다는 것이에요. 

이렇게 사용하면, 내부에 캡슐화된 정적 객체를 교체해서 전체 개념을 테스트 할 수 있어요. 

결국 올바른 대답은, 캡슐화된 객체를 변경할 수 있기 때문에 싱글톤이 율틸리티 클래스보다는 더 좋다는 것이에요.

### 하지만 절대로 싱글톤을 사용하지 마세요. 생각조자 하지마세요

대부분의 클래스가 현재의 로그인된 사용자 정보를 알아야 한다고 가정해봐요.

그러면 어떻게 해야할까요? 무조건 캡슐화를 사용해요.

로그인된 사용자가 필요한 모든 객체안에 사용자를 캡슐화 하면돼요.(찹쉽죠??)

클래스가 작업을 수행하는데 필요한 모든 요소들이 생성자에 제공되고 내부에 캡슐화돼야 해요. 예외는 없어요

너무 많은 것들이 캡슐화 되는거 같나요? 섹션 2.1에서 설명한 것 처럼 클래스를 리팩토링하면 돼요.

### 5. 함수형 프로그래밍(Functional Programming. FP)

### 책에서 권장하는 방식에 따라 객체를 '우아하게'만들었다면, 함수와 객체 사이에는 많은 부분이 유사해져요.

그렇다면 왜 객체를 사용할 까요?

다은은 앞서 봤던 두 정수의 최댓값을 표현하는 클래스에요

```java
class Max implements Number {
    private final int a;
    private final int b;

    public Max(int left, int right) {
        this.a = left;
        this.b = right;
    }
    
    @Override
    public int intValue() {
        return this.a > this.b ? this.a : this.b;
    }
}
```

이 클래스는 다음과 같이 사용할 수 있어요

```java
Number x = new Max(5, 9);
```

FP보다 OOP의 표현력이 더 뛰어나고 강력해요. FP에서는 오직 함수만 사용할 수 있지만, OOP에서는 객체와 메서드를 조합할 수 있어요. 물론 객첼르 제공하는 FP언어들도 있지만. 이런 언어들은 OOP 요소를 포함하는 FP 언어가 아니라 FP 요소를 포함하는 OOP 언어로 간주해요. 또한 FP를 향한 움직임의 일환으로 도입된 Java의 람다 표현식은 진정한 객체지향 스타일로부터 우리를 멀어지게 만들기 때문에 Java의 견고함을 약화 시켜요.

FP는 훌륭한 패러다임이지만, OOP가 더 나아요. 특히 제대로 사용할 경우에는 더 확실해져요.

### 이상적인 OOP언어에서는 클래스와 함께 함수가 포함되어야 해요.

작은 프로시저로 동작하는 Java의 메서드가 아니라. 하나의 출구만 포함하는 순수함 FP 패러다임에 기반하는 진정한 함수를 포함해야 해요.

### 6. 조합 가능한 데코레이터

저자가 사용하기로한 용어.

조합 가능한 데코레이터는 그저 다른 객체를 감싸는 객체일 뿐이에요. 이것은 유명한 디자인 패턴인 데코레이터일 뿐이지만, 이 데코레이터 객체들을 다중계층 구조로 구성하기 시작함녀 다음 예제처름 조합 가능해져요.

```java
names = new Sorted(
           new Unique(
                new Captitalized(
                    new Replaced(
                        new FileNames(
                                new Directory(
                                        "/var/users/*.xml"
                                )
                        ),
                        "([^.]+)//.xml",
                        "$1"
                )
           )
        )
);
```

저자의 관점에선 이 코드는 매우 깔끔하면서 객체지향적이에요.  3.2.2에서 설명했던 것처럼 순수하게 선언형이에요.

이 코드는 어떤 일도 실제로 '수행하지는 않지만', **디렉토리(Directory)**안의 모든 **파일이름(FileNames)**을 정규 표현식을 이용해서 **치환하고(Replaced)**, **대문자로 변경하고(Captitalized)**, 중복된 이름을 제거해서 **유일하게(Unique)** 만들고, 다시 **정렬해서(Sorted)** 컬렉션에 담은 후, 이 **컬렉션을 가리키는 names 객체를 선언**해요. 

방금 객체를 어떻게 만들었는지를 전혀 설명하지 않고도 이 객체가 무엇인지를 설명했어요.

**단지 선언했을 뿐**인데 말이에요

이런 객체를 조합가능한 데코레이터라 불러요.

Directory, FileNames, Replaced, Captialized, Unique, Sorted 클래스 각각은 하나의 데코레이터에요.

객체들의 전체적인 행동은 내부에 캡슐화하고 있는 객체들에 의해 유도돼요.

### 순수한 OOP에서는 C같은 절차적인 언어로부터 물려받은 연산자가 필요하지 않아요.

객체 지향에서는 if, for, switch, while 연산자는 필요없어요. 클래스로 구현된 If, For, Switch, While이 필요할 뿐이에요.

### 지금까지 설명한 것이 정적 메서드와 어떤 연관이 있을까요?

정적 메서드는 조합이 불가능해요. 정적메서드는 앞에서 설명한 모든 일들을 불가능하게 만들어요.

정적 메서드를 포함하는 작은 객체들을 조합해서 더 큰 객체를 만들 수 없어요. 

### 간단히 말해서 정적 메서드는 합성이라는 아이디어와 대치되요. 이것이 OOP에서 정적 메서드를 사용해서는 안되는 또다른 이유에요

## 의견

정적 메서드 사용했다가 교수님한테 크게 털린 느낌이에요.

정적 메서드를 사용하지 말야야 하는 이유가 명확해, 반박 불가능하다 생각해요. 

안좋다 까지만 알고있엇지 이렇게 자세한 이유가 있을지 몰랐어요. 정적 메서드를 사용하지 말아야할 이유가 결국 OOP적으로 개발하는것이라 같다고 생각해요

