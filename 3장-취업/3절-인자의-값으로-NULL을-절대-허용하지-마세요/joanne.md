# 3.3 인자의 값으로 NULL을 절대 허용하지 마세요.

인자의 값으로 널은 무슨 일이 있어도 절대 허용하면 안된다. 
값이 비어있다는 의미로 널을 전달하는 경우가 존재하는데, 그러한 경우 메서드는 다음과 같이 작성되어야한다.
```
public void temp(Obj obj) {
    if (obj == null) {
        sout("null");
    } else {

    }
}
```
이렇게 널인지 확인을 하고, 널이 아닌 경우에만 로직을 수행하도록 한다면 이는 객체의 책임(자신의 존재여부를 스스로 판단하도록 하는)을 빼앗는 것과 같다.

그렇다면, `값이 없는 경우`에는 어떻게 처리해야할까?
객체의 상위에 인터페이스를 만든 뒤 존재하지 않는 객체를 의미하는 객체를 만든다. 다음과 같은 AnyFile은 어떠한 내부 로직도 포함하지 않고 어떤 파일을 전달하든 항상 true를 반환한다. 따라서 null 대신 anyfile 인스턴스를 생성해서 전달하면 된다. 
```
class AnyFile implements Mask {
    @Override
    boolean matches(File file) {
        return true;
    }
}
```

하지만 외부에서 널이 들어오는 경우(클라이언트) 어떻게 처리해야할까?
1. 그냥 무시하고 널포인터예외가 던져지도록 냅둔다. - 널 넣은 니들 잘못임
2. if (obj == null) 을 추가한다. 


## 의견
- null 대신 Optional을 이용할 수 있다. Optional에게 그 책임을 맡기고 외부에서 확인만 해준다면, null을 없앨 수 있다고 생각한다.
- 값을 넘겨줄 때 null이 아님을 보장하고 넘겨준다면 인자로 전달받은 메서드 내부에서 null인지 확인해줄 필요가 없다고 생각한다. 따라서! 나는 null이 생기는 경우 nullPointerException을 던지도록 하는 것이 낫다고 생각한다. 일일히 null인지 모두 확인해주는 것은 불필요하다고 생각한다. 메서드 내부에서는 메서드 내부의 로직만 잘 수행하면 되고, 인자가 비어있는지 아닌지에 대해서는 내부에서 확인할 필요 없이 믿고 사용해야한다고 생각한다. 

3.2부터 책을 읽은 뒤 책을 안보고 글을 작성하고 있어서 그런지 조금 횡설수설하는 감이 크다.. 점점 나아지겠지